<snippet>
    <content><![CDATA[
#include <bits/stdc++.h>
using namespace std;
#ifdef __IS_LEETCODE__
#include "D://template_code//leetcode.cpp"
#endif

#ifdef __IS_LOCAL__
#include "D://template_code//debug.cpp"
using namespace dbg;
#else
#define debug(...) ((void)0)
#endif
// init array start ===================================
template <typename T, size_t N>
void mst(T (&arr)[N], const T& value, size_t size = N) {size = std::min(size, N);for (size_t i = 0; i < size; ++i) arr[i] = value;}
template <typename T, size_t N, typename... Args>
void mst(T (&arr)[N],const typename std::remove_all_extents<T>::type& value,size_t first_dim, Args... dims) {first_dim = std::min(first_dim, N);for (size_t i = 0; i < first_dim; ++i) mst(arr[i], value, dims...);}
// init array end ===================================


#define F(i, s, e, t)  for (int(i) = (s); (t) >= 1 ? ((i) <= (e)) : ((i) >= (e)); (i) += (t))
#define all(v) (v).begin(), (v).end()
#define lower(a, x) std::lower_bound((a).begin(), (a).end(), x) - (a).begin()
#define upper(a, x) std::upper_bound((a).begin(), (a).end(), x) - (a).begin()
#define len(x) int((x).size())
#define pb push_back
#define qb pop_back
#define pf push_front
#define qf pop_front
#define rnq(a) do {std::sort((a).begin(), (a).end());(a).erase(std::unique((a).begin(), (a).end()),(a).end());} while (0)

using ll = long long;
using ull = unsigned long long;
using pll = std::pair<ll, ll>;
using pii = std::pair<int, int>;
using vi = std::vector<int>;
using vll = std::vector<ll>;
using vvi = std::vector<vi>;
constexpr ll  linf = 1e18;
constexpr int inf = 1e9,N = 4e5 + 10,mod = 1e9 + 7;


namespace  Random {
    double random_float(int base = 1) {
        std::random_device rd; 
        std::mt19937 gen(rd());
        std::uniform_real_distribution<> dist_real(0.0, 1.0);
        return dist_real(gen) * base;
    }

    int random_int(int minval,int maxval) {
        std::random_device rd; 
        std::mt19937 gen(rd());
        std::uniform_int_distribution<> dist_int(minval,maxval);
        return int(dist_int(gen));
    }
    std::vector<int> random_int_array(int minval,int maxval){
        int n = random_int(1,20);
        std::vector<int> ans;
        for(int i = 0;i < n;i++) {
            ans.push_back(random_int(minval,maxval));
        }
        return ans;
    }


    // falg
    // az => 'a-z'
    // AZ => 'A-Z'
    // Az => 'a-z' + 'A-Z'
    // aZ => 'a-z' + 'A-Z'
    // 01 => 01
    // 00 => 128
    std::string random_string(std::string flag = "az"){
        std::string ans;
        int build = 1;
        int m = random_int(1,20);
        if(flag.size() == 2) {
            char st = flag[0],ed = flag[1];
            if(st == 'a' && ed == 'z' || st == 'A' && ed == 'Z' || st == '0' && ed == '1') {
                for(int i = 0;i<m;i++) {
                    ans += char(random_int(st,ed));
                }
            }else if(st == 'A' && ed == 'z' || st == 'a' && ed == 'Z') {
                for(int i = 0;i<m;i++) {
                    int ok = random_int(0,1);
                    int c1 = random_int('A', 'Z');
                    int c2 = random_int('a', 'z');
                    ans += char(ok ? c1 : c2);
                }
            }else {
                build = 0;
            }
        }
        if(!build) {
            for(int i = 0;i<m;i++) {
                ans += char(random_int(0,127));
            }
        }
        return ans;
    }


    std::vector<std::string> random_string_array(std::string flag,int min_n = 1,int max_n = 20) {
        int n = random_int(std::max(1,min_n),std::max(1,std::max(min_n,max_n)));
        std::vector<std::string> ss;
        while(n--) {
            ss.push_back(random_string(flag));
        }
        return ss;
    }

}

using namespace Random;


void solve() {
    
}



int main() {
    ios::sync_with_stdio(0);
    cin.tie(0);
    int tt = 1;
    // cin >> tt;
    while(tt--)solve();
    return 0;
}


]]></content>
    <!-- Optional: Set a tabTrigger to define how to trigger the snippet -->
    <tabTrigger>iotest</tabTrigger>
    <!-- Optional: Set a scope to limit where the snippet will trigger -->
    <scope>source.c++</scope>
</snippet>
